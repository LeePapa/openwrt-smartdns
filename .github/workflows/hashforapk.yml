name: Update mirror hashes in Makefile.apk

permissions:
  contents: write

on:
  push:
    branches:
      - master
    paths-ignore:
      - '.github/workflows/**'
  workflow_dispatch:

jobs:
  update-hashes:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout (use PAT to allow downstream workflows)
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT_WORKFLOW }}   # 需提前在仓库 Secrets 里配置：PAT_WORKFLOW（含 repo+workflow）

      - name: Install needed tools
        run: |
          sudo apt-get update
          sudo apt-get install -y jq xz-utils git

      - name: Parse variables from Makefile.apk (strict)
        id: parse
        run: |
          set -e
          MF=Makefile.apk
          [ -f "$MF" ] || { echo "Makefile.apk not found"; exit 1; }

          # 仅匹配 “键 := 值” 的形式；不吞掉 URL 中的冒号
          get_val() {
            local key="$1"
            sed -nE "s|^[[:space:]]*${key}[[:space:]]*:=[[:space:]]*||p" "$MF" | head -n1
          }

          PKG_NAME="$(get_val 'PKG_NAME')"
          PKG_VERSION="$(get_val 'PKG_VERSION')"
          PKG_SOURCE_URL="$(get_val 'PKG_SOURCE_URL')"
          PKG_SOURCE_VERSION="$(get_val 'PKG_SOURCE_VERSION')"

          WEBUI_VERSION="$(get_val 'SMARTDNS_WEBUI_VERSION')"
          WEBUI_URL="$(get_val 'SMARTDNS_WEBUI_SOURCE_URL')"
          WEBUI_COMMIT="$(get_val 'SMARTDNS_WEBUI_SOURCE_VERSION')"
          WEBUI_FILE="$(get_val 'SMARTDNS_WEBUI_FILE')"

          # 去掉可能的引号与结尾注释
          strip_q() { echo "$1" | sed -E 's/[[:space:]]+#.*$//' | sed -E 's/^"(.*)"$/\1/; s/^'\''(.*)'\''$/\1/'; }

          PKG_NAME="$(strip_q "$PKG_NAME")"
          PKG_VERSION="$(strip_q "$PKG_VERSION")"
          PKG_SOURCE_URL="$(strip_q "$PKG_SOURCE_URL")"
          PKG_SOURCE_VERSION="$(strip_q "$PKG_SOURCE_VERSION")"
          WEBUI_VERSION="$(strip_q "$WEBUI_VERSION")"
          WEBUI_URL="$(strip_q "$WEBUI_URL")"
          WEBUI_COMMIT="$(strip_q "$WEBUI_COMMIT")"
          WEBUI_FILE="$(strip_q "$WEBUI_FILE")"

          echo "pkg_name=$PKG_NAME"             >> $GITHUB_OUTPUT
          echo "pkg_ver=$PKG_VERSION"           >> $GITHUB_OUTPUT
          echo "pkg_url=$PKG_SOURCE_URL"        >> $GITHUB_OUTPUT
          echo "pkg_commit=$PKG_SOURCE_VERSION" >> $GITHUB_OUTPUT
          echo "webui_ver=$WEBUI_VERSION"       >> $GITHUB_OUTPUT
          echo "webui_url=$WEBUI_URL"           >> $GITHUB_OUTPUT
          echo "webui_commit=$WEBUI_COMMIT"     >> $GITHUB_OUTPUT
          echo "webui_file=$WEBUI_FILE"         >> $GITHUB_OUTPUT

      - name: Normalize repo URLs (https scheme, GitHub)
        id: norm
        run: |
          set -e
          norm() {
            local u="$1"
            # //github.com/owner/repo.git  -> https://github.com/owner/repo.git
            if echo "$u" | grep -qE '^//github\.com/'; then
              u="https:${u}"
            fi
            # git@github.com:owner/repo.git -> https://github.com/owner/repo.git
            if echo "$u" | grep -qE '^git@github\.com:'; then
              u="https://github.com/$(echo "$u" | sed -E 's#^git@github\.com:##')"
            fi
            # 没有 scheme 的 github.com/owner/repo.git -> https://github.com/owner/repo.git
            if echo "$u" | grep -qE '^github\.com/'; then
              u="https://$u"
            fi
            echo "$u"
          }

          PKG_URL="$(norm '${{ steps.parse.outputs.pkg_url }}')"
          WEBUI_URL="$(norm '${{ steps.parse.outputs.webui_url }}')"

          echo "pkg_url_norm=$PKG_URL"   >> $GITHUB_OUTPUT
          echo "webui_url_norm=$WEBUI_URL" >> $GITHUB_OUTPUT

          echo "Normalized PKG URL : $PKG_URL"
          echo "Normalized WEBUI URL: $WEBUI_URL"

      - name: Compute PKG_MIRROR_HASH (respect PKG_SOURCE_PROTO)
        id: hash_pkg
        run: |
          set -euo pipefail
          PROTO='${{ steps.parse.outputs.pkg_proto }}'
          REPO='${{ steps.norm.outputs.pkg_url_norm }}'
          COMMIT='${{ steps.parse.outputs.pkg_commit }}'
          NAME='${{ steps.parse.outputs.pkg_name }}'
          VER='${{ steps.parse.outputs.pkg_ver }}'

          [ -n "$PROTO" ] || { echo "PKG_SOURCE_PROTO empty"; exit 1; }
          [ -n "$REPO" ]  || { echo "PKG_SOURCE_URL empty";  exit 1; }
          [ -n "$COMMIT" ]|| { echo "PKG_SOURCE_VERSION empty"; exit 1; }

          if [ "$PROTO" != "git" ]; then
            echo "Unsupported PKG_SOURCE_PROTO=$PROTO (only git implemented)"; exit 2
          fi

          git config --global core.autocrlf false
          rm -rf pkg_repo pkg_stage && mkdir -p pkg_stage
          git clone --no-tags --filter=tree:0 "$REPO" pkg_repo
          git -C pkg_repo fetch origin "$COMMIT" --depth=1
          git -C pkg_repo checkout "$COMMIT"

          # 取提交时间戳，用于 --mtime
          TS=$(git -C pkg_repo log -1 --format=%ct)

          # 先用 git archive 提取工作树（不含 .git）
          # 前缀按 OpenWrt 习惯：<pkg>-<version>/
          PREFIX="${NAME}-${VER}/"
          git -C pkg_repo archive --format=tar --prefix="$PREFIX" "$COMMIT" -o pkg_tree.tar

          # 解到 stage 目录
          tar -C pkg_stage -xf pkg_tree.tar

          # 如果有子模块，按 download.pl 的方式把内容拉进来再去掉 .git*（展平）
          if [ -f pkg_repo/.gitmodules ]; then
            git -C pkg_repo submodule update --init --recursive
            # 将子模块内容复制到对应路径（和 download.pl 的“展平后再重新打包”一致）
            while IFS= read -r path; do
              [ -z "$path" ] && continue
              # 去掉前缀后得到在 stage 内的相对路径
              dst="pkg_stage/${PREFIX}${path}"
              mkdir -p "$dst"
              rsync -a --delete --exclude '.git' --exclude '.gitmodules' "pkg_repo/${path}/" "$dst/"
            done < <(git -C pkg_repo config --file .gitmodules --name-only --get-regexp 'submodule\..*\.path' | sed -E 's/^submodule\.(.+)\.path$/\1/' | while read n; do git -C pkg_repo config --file .gitmodules "submodule.${n}.path"; done)
          fi

          # 重新打包：规范 owner/perm/sort/mtime，然后 .tar.xz（OpenWrt 源码包常用 xz）
          OUT="source-${NAME}-${VER}-${COMMIT}.tar.xz"
          tar --numeric-owner --owner=0 --group=0 --mode=a-s \
              --sort=name --mtime="@${TS}" \
              -C pkg_stage -c "${PREFIX%/}" | xz -zc -7e > "$OUT"

          SHA_PKG=$(sha256sum "$OUT" | awk '{print $1}')
          echo "sha_pkg=$SHA_PKG" >> $GITHUB_OUTPUT
          echo "PKG_MIRROR_HASH: $SHA_PKG"

      - name: Compute MIRROR_HASH for smartdns-webui (respect *_SOURCE_PROTO)
        id: hash_webui
        run: |
          set -euo pipefail
          PROTO='${{ steps.parse.outputs.webui_proto }}'
          REPO='${{ steps.norm.outputs.webui_url_norm }}'
          COMMIT='${{ steps.parse.outputs.webui_commit }}'
          VER='${{ steps.parse.outputs.webui_ver }}'
          FILE='${{ steps.parse.outputs.webui_file }}'

          [ -n "$PROTO" ] || { echo "SMARTDNS_WEBUI_SOURCE_PROTO empty"; exit 1; }
          [ -n "$REPO" ]  || { echo "SMARTDNS_WEBUI_SOURCE_URL empty";  exit 1; }
          [ -n "$COMMIT" ]|| { echo "SMARTDNS_WEBUI_SOURCE_VERSION empty"; exit 1; }

          if [ "$PROTO" != "git" ]; then
            echo "Unsupported WEBUI PROTO=$PROTO (only git implemented)"; exit 2
          fi

          git config --global core.autocrlf false
          rm -rf webui_repo webui_stage && mkdir -p webui_stage
          git clone --no-tags --filter=tree:0 "$REPO" webui_repo
          git -C webui_repo fetch origin "$COMMIT" --depth=1
          git -C webui_repo checkout "$COMMIT"

          TS=$(git -C webui_repo log -1 --format=%ct)

          PREFIX="smartdns-webui-${VER}/"
          git -C webui_repo archive --format=tar --prefix="$PREFIX" "$COMMIT" -o webui_tree.tar
          tar -C webui_stage -xf webui_tree.tar

          if [ -f webui_repo/.gitmodules ]; then
            git -C webui_repo submodule update --init --recursive
            while IFS= read -r path; do
              [ -z "$path" ] && continue
              dst="webui_stage/${PREFIX}${path}"
              mkdir -p "$dst"
              rsync

      - name: Update Makefile.apk with new hashes
        id: patch
        run: |
          MF=Makefile.apk
          SHA_PKG='${{ steps.hash_pkg.outputs.sha_pkg }}'
          SHA_WEBUI='${{ steps.hash_webui.outputs.sha_webui }}'

          # 更新 PKG_MIRROR_HASH:=xxxx
          # 仅替换第一处匹配，且保持键名和 := 之间可能的空格
          sed -i -E "0,/^[[:space:]]*PKG_MIRROR_HASH[[:space:]]*:=.*/s//PKG_MIRROR_HASH:=${SHA_PKG}/" "$MF"

          # 更新 Download/smartdns-webui 段中的 MIRROR_HASH:=xxxx
          # 为避免误替换其它段，这里做个简单的区间限定（两步法）
          # 先把整文件打印到临时文件，逐行处理
          awk -v hash="$SHA_WEBUI" '
            BEGIN{in_webui=0}
            {
              if ($0 ~ /^[[:space:]]*define[[:space:]]+Download\/smartdns-webui/) in_webui=1
              if (in_webui && $0 ~ /^[[:space:]]*MIRROR_HASH[[:space:]]*:=/) {
                sub(/:=.*/," := " hash)
              }
              print
              if (in_webui && $0 ~ /^[[:space:]]*endef[[:space:]]*$/) in_webui=0
            }' "$MF" > "$MF.tmp" && mv "$MF.tmp" "$MF"

          # 显示 diff
          echo "---- DIFF ----"
          git --no-pager diff -- "$MF" || true
          echo "--------------"

          # 如果没有变化则跳过提交
          if git diff --quiet -- "$MF"; then
            echo "no_change=true" >> $GITHUB_OUTPUT
          else
            echo "no_change=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit & push
        if: ${{ steps.patch.outputs.no_change == 'false' }}
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add Makefile.apk
          git commit -m "chore: update PKG_MIRROR_HASH and webui MIRROR_HASH"
          git push origin HEAD:${{ github.ref_name }}
